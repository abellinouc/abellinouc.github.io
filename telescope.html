<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pagina HTML5 Basica</title>
  <style>

  </style>

  
</head>
<body>
      <script src="https://app.protobject.com/framework/p.js"></script>
  <script src="config.js"></script>
  

  
    <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: black;
    }

    #touchArea {
      width: 100%;
      height: 100%;
      touch-action: none;
      position: relative;
    }

    #fovDisplay {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-family: sans-serif;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 1.5em;
      pointer-events: none;
    }
  </style>
  
  <div id="touchArea">
  <div id="fovDisplay">FOV: 3.2288591161</div>
</div>
  
  
  
  <script>
    

    
    
    let Orientation = {

		onDataCallback: null,
		
		start(freq=200) {
			this.freq = freq;
			this.timeNow = Date.now();
      this.oldX;
      this.oldY;
			this.horizontal = 0;
			this.vertical = 0;
			this.callback = null;
			this.initSensors();
		},

		initSensors() {
			if ('AbsoluteOrientationSensor' in window) {
				try {
					const options = { frequency: 60 };
					this.orientationSensor = new AbsoluteOrientationSensor(options);

					this.orientationSensor.addEventListener('reading', () => {
						this.calculateOrientation();
					});



					this.orientationSensor.start();
				} catch (error) {
					console.error('Sensor not supported:', error);
				}
			} else {
				console.error('AbsoluteOrientationSensor is not supported by this browser.');
			}
		},

		calculateOrientation() {
			if (!this.orientationSensor) {
				return;
			}

			const quaternion = this.orientationSensor.quaternion;

			if (!quaternion) {
				return;
			}

			const [x, y, z, w] = quaternion;
			const pitch = Math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y));
			const yaw = Math.atan2(2 * (w * z + x * y), 1 - 2 * (y * y + z * z));
      
      if (this.oldX!=yaw || this.oldY!=pitch)
        Protobject.Core.send({h: yaw, v: pitch}).to("index.html");
 
      
      this.oldX=yaw;
      this.oldY=pitch;
      
      

		},

		toDegrees(radians) {
			return radians * (180 / Math.PI);
		},

		onData(callback) {
			this.callback = callback;
		}
	}
    
    
    
    Orientation.start(1);


  </script>



</body>
  
  
<script>
  
  let oldFov;
  
  const MIN_FOV = 0.000004848137;
  const MAX_FOV = 3.22885911619;

  const minLogFov = Math.log(MIN_FOV);
  const maxLogFov = Math.log(MAX_FOV);
  let logFov = maxLogFov;
  let lastY = null;
  const sensitivity = 0.5;

  const fovDisplay = document.getElementById("fovDisplay");
  const touchArea = document.getElementById("touchArea");

  function updateDisplay() {
    const fov = Math.exp(logFov);
    fovDisplay.textContent = `FOV: ${fov.toFixed(10)}`;
   
    if (oldFov!=fov){
      
          Protobject.Core.send({f: fov}).to("index.html");
    }
    
   
    oldFov=fov;
  }

  touchArea.addEventListener("touchstart", (e) => {
    if (e.touches.length === 1) {
      lastY = e.touches[0].clientY;
    }
  });

  touchArea.addEventListener("touchmove", (e) => {
    e.preventDefault();
    if (e.touches.length === 1 && lastY !== null) {
      const currentY = e.touches[0].clientY;
      const deltaY = currentY - lastY;
      logFov += deltaY * sensitivity * 0.01;
      logFov = Math.max(minLogFov, Math.min(maxLogFov, logFov));
      updateDisplay();
      lastY = currentY;
    }
  }, { passive: false });

  touchArea.addEventListener("touchend", () => {
    lastY = null;
  });

  updateDisplay();
</script>
  

</html>
