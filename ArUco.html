<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Aruco Tracking — Calibración y Seguimiento</title>
    <style>
      body {
        margin: 0;
        background: #000;
        color: #fff;
        font-family: sans-serif;
        text-align: center;
      }
      #log {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        max-height: 140px;
        overflow: auto;
        background: rgba(0, 0, 0, 0.6);
        font-family: monospace;
        font-size: 0.9em;
        padding: 8px;
        box-sizing: border-box;
        text-align: left;
        z-index: 1000;
      }
      .error {
        color: #ff6b6b;
      }
      .warn {
        color: #f1c40f;
      }
      .info {
        color: #00d1b2;
      }
    </style>
  </head>
  <body>
    <div id="log"></div>

    <script src="https://app.protobject.com/framework/p.js"></script>
    <script src="config.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <script src="telescope/utils/protobject.js"></script>

    <script>
      const logDiv = document.getElementById("log");

      // IDs de marcadores (ejemplo: 0–7 son esquinas distribuidas por el mapa)
      const referenceMarkers = {
        0: [0.035, 0.05], // top-left
        1: [0.965, 0.05], // top-right
        2: [0.965, 0.95], // bottom-right
        3: [0.035, 0.95], // bottom-left
        4: [0.5, 0.05], // top middle
        5: [0.5, 0.95], // bottom middle
        6: [0.035, 0.5], // left middle
        7: [0.965, 0.5], // right middle
      };

      const telescopeMarker = 10; // ID real del telescopio
      const N = 5; // muestras para promedio
      const MIN_DELTA = 0.009;
      const REPROJ_THRESHOLD = 0.04;

      let coordBuffer = [];
      let lastSent = null;
      let stage = "calibration";
      let savedHomography = null;

      function showMessage(msg, type = "info") {
        const d = document.createElement("div");
        d.className = type;
        d.textContent = `[${type.toUpperCase()}] ${msg}`;
        logDiv.appendChild(d);
        logDiv.scrollTop = logDiv.scrollHeight;
        console.log(msg);
      }

      function startCamera() {
        try {
          Protobject.Aruco.start(1000, 0);
          Protobject.Aruco.showPreview({
            top: 0,
            left: 0,
            width: window.innerWidth,
            height: window.innerHeight,
          });
          showMessage("Cámara iniciada.", "info");
        } catch (e) {
          showMessage("Error iniciando cámara: " + e.message, "error");
        }
      }

      // ---------------- Homografía con mínimos cuadrados ----------------

      function computeHomographyLS(srcPts, dstPts) {
        const A = [],
          b = [];
        for (let i = 0; i < srcPts.length; i++) {
          const [x, y] = srcPts[i];
          const [u, v] = dstPts[i];
          A.push([x, y, 1, 0, 0, 0, -u * x, -u * y]);
          b.push(u);
          A.push([0, 0, 0, x, y, 1, -v * x, -v * y]);
          b.push(v);
        }
        try {
          // resolver en mínimos cuadrados
          const At = numeric.transpose(A);
          const AtA = numeric.dot(At, A);
          const Atb = numeric.dot(At, b);
          const h8 = numeric.solve(AtA, Atb);

          return [
            [h8[0], h8[1], h8[2]],
            [h8[3], h8[4], h8[5]],
            [h8[6], h8[7], 1],
          ];
        } catch (e) {
          showMessage("Error resolviendo homografía LS: " + e.message, "warn");
          return null;
        }
      }

      function applyHomography(H, x, y) {
        const denom = H[2][0] * x + H[2][1] * y + H[2][2];
        if (!isFinite(denom) || Math.abs(denom) < 1e-8) return null;
        const X = (H[0][0] * x + H[0][1] * y + H[0][2]) / denom;
        const Y = (H[1][0] * x + H[1][1] * y + H[1][2]) / denom;
        return [X, Y];
      }

      function reprojectionError(H, srcPts, dstPts) {
        let sum = 0;
        for (let i = 0; i < srcPts.length; i++) {
          const p = applyHomography(H, srcPts[i][0], srcPts[i][1]);
          if (!p) return Infinity;
          const dx = p[0] - dstPts[i][0];
          const dy = p[1] - dstPts[i][1];
          sum += Math.sqrt(dx * dx + dy * dy);
        }
        return sum / srcPts.length;
      }

      function median(arr) {
        const s = arr.slice().sort((a, b) => a - b);
        const m = Math.floor(s.length / 2);
        return s.length % 2 ? s[m] : (s[m - 1] + s[m]) / 2;
      }

      // ---------------- Conversión a Mercator ----------------

      function normToLonLat(normX, normY) {
        const lon = -180 + normX * 360;
        // mercator inversa
        const mercY = Math.PI * (1 - 2 * normY);
        const lat = (180 / Math.PI) * Math.atan(Math.sinh(mercY));
        return [lat, lon];
      }

      // ---------------- Main loop ----------------

      Protobject.Aruco.onData((data) => {
        try {
          const ids = Object.keys(data).map((id) => parseInt(id));

          if (stage === "calibration") {
            const commonIds = ids.filter(
              (id) => referenceMarkers[id] !== undefined
            );
            if (commonIds.length < 8) {
              showMessage("Faltan marcadores para calibrar.", "warn");
              return;
            }
            const srcPts = [],
              dstPts = [];
            for (let id of commonIds) {
              const p = data[id].position;
              srcPts.push([p.x, p.y]);
              dstPts.push(referenceMarkers[id]); // coords normalizadas [0,1]
            }
            const H = computeHomographyLS(srcPts, dstPts);
            if (!H) return;

            if (reprojectionError(H, srcPts, dstPts) > REPROJ_THRESHOLD) {
              showMessage("Error alto en calibración.", "warn");
              return;
            }
            savedHomography = H;
            stage = "tracking";
            showMessage(
              "Calibración completa con " + commonIds.length + " marcadores.",
              "info"
            );
            return;
          }

          if (stage === "tracking") {
            if (!ids.includes(telescopeMarker)) {
              showMessage("No se detecta el telescopio.", "warn");
              return;
            }
            const pT = data[telescopeMarker].position;
            const mapped = applyHomography(savedHomography, pT.x, pT.y);
            if (!mapped) return;
            let [normX, normY] = mapped;

            // límites
            normX = Math.max(-0.2, Math.min(1.2, normX));
            normY = Math.max(-0.2, Math.min(1.2, normY));

            const [lat, lon] = normToLonLat(normX, normY);

            coordBuffer.push({ lat, lon });
            if (coordBuffer.length > N) coordBuffer.shift();

            const medLat = median(coordBuffer.map((c) => c.lat));
            const medLon = median(coordBuffer.map((c) => c.lon));

            if (
              lastSent &&
              Math.abs(medLat - lastSent.lat) < MIN_DELTA &&
              Math.abs(medLon - lastSent.lon) < MIN_DELTA
            ) {
              return;
            }
            lastSent = { lat: medLat, lon: medLon };
            showMessage(
              `Enviando: lat=${medLat.toFixed(5)}, lon=${medLon.toFixed(5)}`,
              "info"
            );

            Protobject.Core.send({ lat: medLat, lon: medLon }).to("index.html");
            Protobject.Core.send({ lat: medLat, lon: medLon }).to(
              "telescope.html"
            );
          }
        } catch (err) {
          showMessage("Error: " + err.message, "error");
          console.error(err);
        }
      });

      startCamera();
    </script>
  </body>
</html>
