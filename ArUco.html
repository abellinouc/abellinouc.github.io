<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Aruco Tracking — Calibración y Seguimiento</title>
    <style>
      body {
        margin: 0;
        background: #000;
        color: #fff;
        font-family: sans-serif;
        text-align: center;
      }
      #log {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        max-height: 140px;
        overflow: auto;
        background: rgba(0, 0, 0, 0.6);
        font-family: monospace;
        font-size: 0.9em;
        padding: 8px;
        box-sizing: border-box;
        text-align: left;
        z-index: 1000;
      }
      .error {
        color: #ff6b6b;
      }
      .warn {
        color: #f1c40f;
      }
      .info {
        color: #00d1b2;
      }
    </style>
  </head>
  <body>
    <div id="log"></div>

    <script src="https://app.protobject.com/framework/p.js"></script>
    <script src="config.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <script src="telescope/utils/protobject.js"></script>

    <script>
      const logDiv = document.getElementById("log");

      // IDs de marcadores
      const cornerMarkers = {
        topLeft: 0,
        topRight: 1,
        bottomLeft: 2,
        bottomRight: 3,
      };
      const telescopeMarker = 4; // ID real del telescopio (Aruco)
      const N = 5; // muestras para el promedio
      const MIN_DELTA = 0.0008;
      const REPROJ_THRESHOLD = 0.04;

      let coordBuffer = [];
      let lastSent = null;
      let stage = "calibration";
      let savedHomography = null;

      function showMessage(msg, type = "info") {
        const d = document.createElement("div");
        d.className = type;
        d.textContent = `[${type.toUpperCase()}] ${msg}`;
        logDiv.appendChild(d);
        logDiv.scrollTop = logDiv.scrollHeight;
        console.log(msg);
      }

      function startCamera() {
        try {
          Protobject.Aruco.start(1000, 1);
          Protobject.Aruco.showPreview({
            top: 0,
            left: 0,
            width: window.innerWidth,
            height: window.innerHeight,
          });
          showMessage("Cámara iniciada.", "info");
        } catch (e) {
          showMessage("Error iniciando cámara: " + e.message, "error");
        }
      }

      function orderCorners(pts) {
        const sorted = pts.slice().sort((a, b) => a.y - b.y);
        const top = sorted.slice(0, 2).sort((a, b) => a.x - b.x);
        const bottom = sorted.slice(2, 4).sort((a, b) => a.x - b.x);
        return [top[0], top[1], bottom[1], bottom[0]];
      }

      function computeHomography(srcPts, dstPts) {
        const A = [],
          b = [];
        for (let i = 0; i < 4; i++) {
          const [x, y] = srcPts[i],
            [u, v] = dstPts[i];
          A.push([x, y, 1, 0, 0, 0, -u * x, -u * y]);
          b.push(u);
          A.push([0, 0, 0, x, y, 1, -v * x, -v * y]);
          b.push(v);
        }
        try {
          const h8 = numeric.solve(A, b);
          return [
            [h8[0], h8[1], h8[2]],
            [h8[3], h8[4], h8[5]],
            [h8[6], h8[7], 1],
          ];
        } catch (e) {
          showMessage("Error resolviendo homografía: " + e.message, "warn");
          return null;
        }
      }

      function applyHomography(H, x, y) {
        const denom = H[2][0] * x + H[2][1] * y + H[2][2];
        if (!isFinite(denom) || Math.abs(denom) < 1e-8) return null;
        const X = (H[0][0] * x + H[0][1] * y + H[0][2]) / denom;
        const Y = (H[1][0] * x + H[1][1] * y + H[1][2]) / denom;
        return [X, Y];
      }

      function reprojectionError(H, srcPts, dstPts) {
        let sum = 0;
        for (let i = 0; i < 4; i++) {
          const p = applyHomography(H, srcPts[i][0], srcPts[i][1]);
          if (!p) return Infinity;
          const dx = p[0] - dstPts[i][0];
          const dy = p[1] - dstPts[i][1];
          sum += Math.sqrt(dx * dx + dy * dy);
        }
        return sum / 4;
      }

      function median(arr) {
        const s = arr.slice().sort((a, b) => a - b);
        const m = Math.floor(s.length / 2);
        return s.length % 2 ? s[m] : (s[m - 1] + s[m]) / 2;
      }

      Protobject.Aruco.onData((data) => {
        try {
          const ids = Object.keys(data).map((id) => parseInt(id));
          if (stage === "calibration") {
            const needed = Object.values(cornerMarkers);
            if (!needed.every((id) => ids.includes(id))) {
              showMessage("Faltan esquinas para calibrar.", "warn");
              return;
            }
            const pts = [
              {
                x: data[cornerMarkers.topLeft].position.x,
                y: data[cornerMarkers.topLeft].position.y,
              },
              {
                x: data[cornerMarkers.topRight].position.x,
                y: data[cornerMarkers.topRight].position.y,
              },
              {
                x: data[cornerMarkers.bottomRight].position.x,
                y: data[cornerMarkers.bottomRight].position.y,
              },
              {
                x: data[cornerMarkers.bottomLeft].position.x,
                y: data[cornerMarkers.bottomLeft].position.y,
              },
            ];
            const ordered = orderCorners(pts);
            const srcPts = ordered.map((p) => [p.x, p.y]);
            const dstPts = [
              [0, 0],
              [1, 0],
              [1, 1],
              [0, 1],
            ];
            const H = computeHomography(srcPts, dstPts);
            if (!H) return;
            if (reprojectionError(H, srcPts, dstPts) > REPROJ_THRESHOLD) {
              showMessage("Error alto en calibración.", "warn");
              return;
            }
            savedHomography = H;
            stage = "tracking";
            showMessage("Calibración completa. Pasando a seguimiento.", "info");
            return;
          }

          if (stage === "tracking") {
            if (!ids.includes(telescopeMarker)) {
              showMessage("No se detecta el telescopio.", "warn");
              return;
            }
            const pT = data[telescopeMarker].position;
            const mapped = applyHomography(savedHomography, pT.x, pT.y);
            if (!mapped) return;
            let [normX, normY] = mapped;

            // límites para evitar ruido extremo
            normX = Math.max(-0.2, Math.min(1.2, normX));
            normY = Math.max(-0.2, Math.min(1.2, normY));

            // convertir a coordenadas simuladas
            const lon = -180 + normX * 360;
            const lat = 90 - normY * 180;

            coordBuffer.push({ lat, lon });
            if (coordBuffer.length > N) coordBuffer.shift();

            const medLat = median(coordBuffer.map((c) => c.lat));
            const medLon = median(coordBuffer.map((c) => c.lon));

            if (
              lastSent &&
              Math.abs(medLat - lastSent.lat) < MIN_DELTA &&
              Math.abs(medLon - lastSent.lon) < MIN_DELTA
            ) {
              showMessage(
                `No hay cambio significativo: lat=${medLat.toFixed(
                  5
                )}, lon=${medLon.toFixed(5)}`,
                "info"
              );
              return;
            }
            lastSent = { lat: medLat, lon: medLon };
            showMessage(
              `Enviando: lat=${medLat.toFixed(5)}, lon=${medLon.toFixed(5)}`,
              "info"
            );

            // ahora enviamos lat/lon reales al index.html
            Protobject.Core.send({ lat: medLat, lon: medLon }).to("index.html");
            // Protobject.Core.send({ h: this.oldX, v: this.oldY }).to("index.html");
          }
        } catch (err) {
          showMessage("Error: " + err.message, "error");
          console.error(err);
        }
      });

      startCamera();
    </script>
  </body>
</html>
