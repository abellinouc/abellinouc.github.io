<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stellarium Web Engine</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
      }

      #stel {
        width: 100%;
        height: 100%;
        position: fixed;
        inset: 0;
      }

      #stel-canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
  </head>

  <body>
    <div id="stel">
      <canvas id="stel-canvas"></canvas>
    </div>

    <script src="stellarium-web-engine.js"></script>

    <script>
      // ============================
      // Parámetros base (limit_mag/params.js)
      // ============================
      let FO, FD, FT, FS, K, MZZ, XX, BS, FB, DP, FP, FA, FM, FC, B, CC, KK, FE, TH, FR, I, IS, M;

      let DIAMETER = 100;
      let FOCAL_LENGTH = 1200;
      let EYEPIECE_FL = 25;
      let EYEPIECE_AFOV = 50;
      let CLEANLINESS = 0;
      let TELESCOPE_TYPE = 2;
      let COATING = 88;

      let PUPIL = 7;
      let AGE = 30;
      let EXPERIENCE = 3;

      let SQM_READING = 20;
      let CITY_SQM_READING = 20;
      let STAR_COLOR_INDEX = 0.6;
      let ZENITH_DISTANCE = 0;
      let EXTINCTION = 0.2;
      let SEEING_DISK_DIAMETER = 3;

      // ============================
      // Utilidades (limit_mag/limit_magnitude.js)
      // NOTA: Estas funciones se mantienen por compatibilidad
      // pero NO se usan para limitar visibilidad (modo "todo visible")
      // ============================
      function computeNELM() {
        let SQ = parseFloat(SQM_READING);
        let T = SQ - 19.2;
        let NELM = 7.93 - 5 * Math.log10(1 + 10 * Math.pow(10, -0.4 * T));
        return NELM;
      }

      function computeEyePupil() {
        let E = 7 - (AGE - 20) / 30;
        E = Math.max(2, Math.min(7, E));
        return E;
      }

      function calculate_limit_mag() {
        let UseInch = false;
        let D = parseFloat(DIAMETER);
        if (UseInch) D = D * 25.4;

        let MG = parseFloat(FOCAL_LENGTH / EYEPIECE_FL);
        let MZ = parseFloat(computeNELM());
        let CI = parseFloat(STAR_COLOR_INDEX);
        let Z = parseFloat(ZENITH_DISTANCE) * Math.PI / 180;
        let KV = parseFloat(EXTINCTION);
        let SE = parseFloat(SEEING_DISK_DIAMETER);
        let EX = EXPERIENCE;
        let DE = parseFloat(PUPIL);

        if (isNaN(DE)) {
          DE = computeEyePupil();
          PUPIL = DE;
        }

        if (isNaN(MZ)) {
          MZ = computeNELM();
        }

        let MT = 0;
        if (TELESCOPE_TYPE == 1) {
          MT = 0.2;
        }
        if (TELESCOPE_TYPE == 2) {
          MT = 0.0;
        }
        if (TELESCOPE_TYPE == 3) {
          MT = 0.1;
        }

        let FS = (COATING / 100) * (1 - CLEANLINESS);
        let F = Math.pow(FS, 2);
        let CS = Math.pow(10, -0.4 * KV * (1 / Math.cos(Z) - 1));
        let BS = Math.pow(10, 0.4 * (MZ - 6.5));
        let FC = Math.pow(10, 0.4 * (CI - 0.6));
        let FE = Math.pow(10, -0.4 * (EX - 1) / 4);
        let K = 2.5 * Math.log10(
          (D * D * F * CS * FC * FE) / (DE * DE * BS)
        );

        let HT = Math.max(1, MG / 2);
        let HH = 1 / Math.sqrt(1 + Math.pow(HT, 2));
        let SEF = Math.max(1, SE / 2);
        let HF = 1 / Math.sqrt(1 + Math.pow(SEF, 2));
        let S = 2.5 * Math.log10(HH * HF);

        let ML = MZ + K + MT + S;
        return ML;
      }

      // ============================
      // Estado global mínimo
      // ============================
      window.MIN_FOV = 0.000005;
      window.MAX_FOV = 3.228859;
      window.FOV_STEP = 0.000001;
      window.logFov = Math.log(MAX_FOV);
      window.current_fov = MAX_FOV;

      window.currentBlur = 5;

      let engine = null;
      let bortle = null;
      window.engine = engine;
      window.bortle = bortle;

      // ============================
      // util/time.js (solo lo necesario)
      // ============================
      function toJulianDateIso(iso) {
        const now = new Date(iso);
        const jd = now.getTime() / 86400000 + 2440587.5;
        const mjd = jd - 2400000.5;
        return mjd;
      }

      // ============================
      // util/location.js (reutilizado)
      // ============================
      function magToBortle(magArcsec2) {
        if (magArcsec2 > 21.99) return 1;
        if (magArcsec2 > 21.89) return 2;
        if (magArcsec2 > 21.69) return 3;
        if (magArcsec2 > 20.49) return 4;
        if (magArcsec2 > 19.5) return 5;
        if (magArcsec2 > 18.94) return 6;
        if (magArcsec2 > 18.38) return 7;
        if (magArcsec2 > 16.53) return 8;
        return 9;
      }

      function applyPollution({ mag = 20 }) {
        if (!engine || !engine.core) return;

        SQM_READING = mag;
        bortle = magToBortle(mag);
        window.bortle = bortle;

        engine.core.bortle_index = bortle;
        // Modo "todo visible": siempre mostrar Vía Láctea
        engine.core.milkyway.visible = true;
        // Mantener magnitud límite alta para máxima visibilidad
        engine.core.display_limit_mag = 25;
        engine.core.star_relative_scale = 0.6;
      }

      async function applyLocation({ cityName = "Custom", lat = 0, lon = 0, elev = 0, mag = null }) {
        if (!engine) return;

        engine.core.observer.latitude = lat * (Math.PI / 180);
        engine.core.observer.longitude = lon * (Math.PI / 180);
        engine.core.observer.elevation = elev;

        CITY_SQM_READING = mag;
        applyPollution({ mag });
      }

      // ============================
      // util/overlay.js (solo blur)
      // ============================
      function updateStellariumBlur({ blur }) {
        const canvasBlur = document.getElementById("stel-canvas");
        if (canvasBlur) canvasBlur.style.filter = `blur(${blur}px)`;
      }

      // ============================
      // util/stel.js (reutilizado)
      // ============================
      function updateStellariumView({ h, v }) {
        if (!engine || !engine.core || !engine.core.observer) return;
        engine.core.observer.yaw = -h;
        engine.core.observer.pitch = v;
      }

      function updateStellariumFov({ fov }) {
        if (!engine || !engine.core) return;
        engine.core.fov = fov;

        // Actualizar EYEPIECE_FL para cálculos de lentes si es necesario
        const deg_fov = (fov * 180) / Math.PI;
        EYEPIECE_FL = (FOCAL_LENGTH * deg_fov) / 100;
        // Modo "todo visible": mantener magnitud límite alta
        engine.core.display_limit_mag = 25;
      }

      // ============================
      // util/initStel.js (reutilizado)
      // ============================
      function initializeStelEngine() {
        StelWebEngine({
          wasmFile: "stellarium-web-engine.wasm",
          canvas: document.getElementById("stel-canvas"),
          async onReady(stel) {
            engine = stel;
            window.engine = engine;
            const core = stel.core;

            core.observer.utc = toJulianDateIso(new Date().toISOString());

            const defaultLocation = {
              cityName: "Santiago",
              lat: -33.4489,
              lon: -70.6693,
              elev: 570,
              mag: 17.13,
            };

            const baseUrl = "http://localhost:5000/"
            const baseUrlBig = "http://localhost:5000/"

            const dataSourcePromises = [];

            dataSourcePromises.push(
              core.stars.addDataSource({
                url:
                  baseUrl +
                  "swe-data-packs/minimal/2020-09-01/minimal_2020-09-01_186e7ee2/stars",
                key: "minimal",
              })
            );
            dataSourcePromises.push(
              core.stars.addDataSource({
                url:
                  baseUrl +
                  "swe-data-packs/base/2020-09-01/base_2020-09-01_1aa210df/stars",
                key: "base",
              })
            );
            dataSourcePromises.push(
              core.landscapes.addDataSource({
                url: baseUrl + "landscapes/v1/guereins",
                key: "guereins",
              })
            );

            [
              "moon",
              "sun",
              "jupiter",
              "mercury",
              "venus",
              "mars",
              "saturn",
              "uranus",
              "neptune",
              "io",
              "europa",
              "ganymede",
              "callisto",
              "moon-normal",
            ].forEach((p) => {
              dataSourcePromises.push(
                core.planets.addDataSource({
                  url: baseUrl + `surveys/sso/${p}/v1`,
                  key: p,
                })
              );
            });

            dataSourcePromises.push(
              core.stars.addDataSource({
                url:
                  baseUrl +
                  "swe-data-packs/extended/2020-03-11/extended_2020-03-11_26aa5ab8/stars",
                key: "extended",
              })
            );
            dataSourcePromises.push(
              core.dss.addDataSource({
                url: baseUrlBig + "surveys/gaia/v1",
                key: "gaia",
              })
            );

            dataSourcePromises.push(
              core.skycultures.addDataSource({
                url: baseUrl + "skycultures/v3/western",
                key: "western",
              })
            );

            dataSourcePromises.push(
              core.dsos.addDataSource({
                url:
                  baseUrl +
                  "swe-data-packs/base/2020-09-01/base_2020-09-01_1aa210df/dso",
              })
            );
            dataSourcePromises.push(
              core.dsos.addDataSource({
                url:
                  baseUrl +
                  "swe-data-packs/extended/2020-03-11/extended_2020-03-11_26aa5ab8/dso",
              })
            );

            dataSourcePromises.push(
              core.milkyway.addDataSource({ url: baseUrl + "surveys/milkyway/v1" })
            );
            dataSourcePromises.push(
              core.dss.addDataSource({ url: baseUrlBig + "surveys/dss/v1" })
            );
            dataSourcePromises.push(
              core.minor_planets.addDataSource({
                url: baseUrl + "mpc/v1/mpcorb.dat",
                key: "mpc_asteroids",
              })
            );
            dataSourcePromises.push(
              core.comets.addDataSource({
                url: baseUrl + "mpc/v1/CometEls.txt?v=2019-12-17",
                key: "mpc_comets",
              })
            );

            try {
              await Promise.all(dataSourcePromises);
              
              // ============================
              // Modo "todo visible" sin realismo
              // ============================
              // Desactivar atmósfera y paisaje
              core.atmosphere.visible = false;
              core.landscapes.visible = false;
              
              // Activar todas las etiquetas
              core.stars.hints_visible = true;
              core.planets.hints_visible = true;
              core.dsos.hints_visible = true;
              core.minor_planets.hints_visible = true;
              core.comets.hints_visible = true;
              
              // Activar cardinales y vía láctea
              core.cardinals.visible = true;
              core.milkyway.visible = true;
              
              // Maximizar visibilidad: magnitud límite muy alta
              core.display_limit_mag = 25;
              
              // Escala de exposición para mejor visibilidad
              core.exposure_scale = 2;

            } catch (error) {
              console.error("Error loading data sources:", error);
            }

            applyLocation(defaultLocation);
            applyLensLevel(currentLensLevel);
          },
        });
      }

      // ============================
      // Orientación (telescope/utils/stellarium.js)
      // ============================
      function unwrapAngle(angle, reference) {
        while (angle - reference > Math.PI) angle -= 2 * Math.PI;
        while (angle - reference < -Math.PI) angle += 2 * Math.PI;
        return angle;
      }

      window.updatePitchYaw = window.updatePitchYaw || function () {};

      window.Orientation = {
        gyroFreq: 100,
        absFreq: 30,
        calibDuration: 3,

        fovThreshold: 0.8,
        gyroDeadzone: 0.003,

        dynamicThreshold: 0.02,
        dynamicGainMultiplier: 10.0,
        dynamicSmoothingFactor: 0.15,

        gyroSensor: null,
        absSensor: null,
        running: false,
        calibrating: false,
        gyroBias: { x: 0, y: 0, z: 0 },
        biasSamples: [],
        calibSamplesNeeded: 300,

        orient: { pitch: 0, yaw: 0 },
        absOrientLast: null,
        currentMode: "absolute",

        oldX: null,
        oldY: null,

        rawDynamicX: null,
        rawDynamicY: null,

        lastTime: null,
        _pendingRAF: false,

        quaternionToEuler(q) {
          if (!q) return { yaw: 0, pitch: 0 };
          const x = q[0],
            y = q[1],
            z = q[2],
            w = q[3];
          const pitch = Math.atan2(2 * (w * x + y * z), 1 - 2 * (x * x + y * y));
          const yaw = Math.atan2(2 * (w * z + x * y), 1 - 2 * (y * y + z * z));
          return { yaw, pitch };
        },

        start() {
          this.onCalibReading = this.onCalibReading.bind(this);
          this.onSensorReading = this.onSensorReading.bind(this);
          this.onAbsReading = this.onAbsReading.bind(this);
          this.startSensors();
        },

        stop() {
          this.running = false;
          this.calibrating = false;
          if (this.gyroSensor) {
            try {
              this.gyroSensor.stop();
            } catch (e) {}
          }
          if (this.absSensor) {
            try {
              this.absSensor.stop();
            } catch (e) {}
          }
        },

        async requestIOSPermissionIfNeeded() {
          if (
            typeof DeviceOrientationEvent !== "undefined" &&
            typeof DeviceOrientationEvent.requestPermission === "function"
          ) {
            await DeviceOrientationEvent.requestPermission();
          }
        },

        async startSensors() {
          try {
            await this.requestIOSPermissionIfNeeded();
            if (!("Gyroscope" in window) || !("AbsoluteOrientationSensor" in window)) {
              throw new Error("Sensori necessari non disponibili");
            }
            this.gyroSensor = new Gyroscope({ frequency: this.gyroFreq });
            this.absSensor = new AbsoluteOrientationSensor({ frequency: this.absFreq });

            this.gyroSensor.addEventListener("error", (e) =>
              console.error("Error Gyro:", e)
            );
            this.absSensor.addEventListener("error", (e) =>
              console.error("Error Abs:", e)
            );

            this.startCalibration();
          } catch (err) {
            console.error("Errore avvio sensori:", err);
            window.updatePitchYaw(0, 0, { status: "Error: " + err.message });
          }
        },

        startCalibration() {
          if (!this.gyroSensor || !this.absSensor) return;
          this.calibrating = true;
          this.running = false;
          this.biasSamples = [];
          this.calibSamplesNeeded = this.gyroFreq * this.calibDuration;
          this.currentMode = "absolute";

          window.updatePitchYaw(0, 0, { status: "Calibrating..." });

          this.gyroSensor.addEventListener("reading", this.onCalibReading);
          this.absSensor.addEventListener("reading", this.onAbsReading);

          this.gyroSensor.start();
          this.absSensor.start();
        },

        onCalibReading() {
          if (this.biasSamples.length < this.calibSamplesNeeded) {
            this.biasSamples.push({
              x: this.gyroSensor.x,
              y: this.gyroSensor.y,
              z: this.gyroSensor.z,
            });
          } else {
            this.finishCalibration();
          }
        },

        finishCalibration() {
          this.calibrating = false;
          this.gyroSensor.removeEventListener("reading", this.onCalibReading);

          const avg = this.biasSamples.reduce(
            (acc, r) => ({
              x: acc.x + r.x,
              y: acc.y + r.y,
              z: acc.z + r.z,
            }),
            { x: 0, y: 0, z: 0 }
          );
          const len = this.biasSamples.length || 1;
          this.gyroBias = { x: avg.x / len, y: avg.y / len, z: avg.z / len };

          if (this.absOrientLast) {
            const euler = this.quaternionToEuler(this.absOrientLast);
            this.oldX = euler.yaw;
            this.oldY = euler.pitch;
          }

          this.lastTime = performance.now();
          this.gyroSensor.addEventListener("reading", this.onSensorReading);
          this.running = true;
        },

        onAbsReading() {
          if (!this.absSensor) return;
          this.absOrientLast = this.absSensor.quaternion;
        },

        onSensorReading() {
          if (this.calibrating) {
            this.lastTime = performance.now();
            return;
          }

          const now = performance.now();
          const dt = Math.max(1e-6, (now - this.lastTime) / 1000);
          this.lastTime = now;

          let currentV = 0.05;
          try {
            if (typeof logFov !== "undefined") currentV = Math.exp(logFov);
          } catch (e) {}

          const inDynamicZone = currentV < this.dynamicThreshold;

          if (inDynamicZone) {
            let wx = this.gyroSensor.x - this.gyroBias.x;
            let wz = this.gyroSensor.z - this.gyroBias.z;

            let rawDeltaYaw = wz * dt;
            let rawDeltaPitch = wx * dt;

            const zoomRatio = currentV / this.dynamicThreshold;
            const speed = Math.hypot(rawDeltaYaw, rawDeltaPitch);
            const noiseFloor = 0.002;

            let precisionGain;
            if (speed < noiseFloor) {
              precisionGain = 0.05;
            } else {
              precisionGain = Math.min(1.0, Math.pow(speed * 100, 2));
            }

            const totalFactor =
              zoomRatio * precisionGain * this.dynamicGainMultiplier;

            if (this.rawDynamicX === null) {
              this.rawDynamicX = this.oldX;
              this.rawDynamicY = this.oldY;
            }

            this.rawDynamicX += rawDeltaYaw * totalFactor;
            this.rawDynamicY += rawDeltaPitch * totalFactor;

            const k = this.dynamicSmoothingFactor;

            this.oldX += (this.rawDynamicX - this.oldX) * k;
            this.oldY += (this.rawDynamicY - this.oldY) * k;

            this.orient.yaw = this.oldX;
            this.orient.pitch = this.oldY;

            this.updateView(currentV, "DYNAMIC");
          } else {
            this.rawDynamicX = null;
            this.rawDynamicY = null;

            if (this.currentMode === "absolute" && this.absOrientLast) {
              const euler = this.quaternionToEuler(this.absOrientLast);
              this.orient.pitch = euler.pitch;
              this.orient.yaw = euler.yaw;
            } else {
              let wx = this.gyroSensor.x - this.gyroBias.x;
              let wz = this.gyroSensor.z - this.gyroBias.z;
              if (Math.abs(wx) < this.gyroDeadzone) wx = 0;
              if (Math.abs(wz) < this.gyroDeadzone) wz = 0;
              this.orient.pitch += wx * dt;
              this.orient.yaw += wz * dt;
            }

            this.runApplicationLogic(this.orient.pitch, this.orient.yaw, currentV);
          }
        },

        runApplicationLogic(pitch, yaw, fov) {
          const requiredMode = fov < this.fovThreshold ? "gyro" : "absolute";

          if (requiredMode !== this.currentMode) {
            this.transitionToMode(requiredMode);
          }

          const sensitivity = this.currentMode === "gyro" ? 0.1 : 0.5;

          if (this.oldX === null || this.oldY === null) {
            this.oldX = yaw;
            this.oldY = pitch;
            return;
          }

          const adjustedYaw = unwrapAngle(yaw, this.oldX);

          this.oldX += (adjustedYaw - this.oldX) * sensitivity;
          this.oldY += (pitch - this.oldY) * sensitivity;

          this.updateView(fov, this.currentMode);
        },

        transitionToMode(newMode) {
          if (newMode === "gyro" && this.currentMode === "absolute") {
            if (this.absOrientLast) {
              const euler = this.quaternionToEuler(this.absOrientLast);
              this.orient.pitch = euler.pitch;
              this.orient.yaw = euler.yaw;
              this.oldX = euler.yaw;
              this.oldY = euler.pitch;
            }
          } else if (newMode === "absolute" && this.currentMode === "gyro") {
            if (this.absOrientLast) {
              const euler = this.quaternionToEuler(this.absOrientLast);
              this.oldX = unwrapAngle(euler.yaw, this.oldX);
              this.oldY = euler.pitch;
            }
          }
          this.currentMode = newMode;
        },

        updateView(vVal, modeName) {
          const h = this.oldX;
          const v = this.oldY;

          window.updatePitchYaw(v, h, {
            vVal: vVal,
            mode: modeName,
            status: "Running",
          });

          if (!this._pendingRAF) {
            this._pendingRAF = true;
            requestAnimationFrame(() => {
              updateStellariumView({ h, v });
              this._pendingRAF = false;
            });
          }
        },
      };

      // ============================
      // Lentes + teclado
      // ============================
      const LENS_FOCAL_LENGTHS = [null, 40, 32, 24, 16, 10, 4];
      const NO_LENS_BLUR = 90;
      let currentLensLevel = 0;

      function computeFovFromEyepiece(eyepieceFl) {
        const m = FOCAL_LENGTH / eyepieceFl;
        const proyection_const = 100;
        let new_fov = proyection_const / m;
        new_fov = (new_fov * Math.PI) / 180;
        return new_fov;
      }

      function applyLensLevel(level) {
        currentLensLevel = level;

        if (level === 0) {
          current_fov = MAX_FOV;
          logFov = Math.log(current_fov);
          updateStellariumFov({ fov: current_fov });
          updateStellariumBlur({ blur: NO_LENS_BLUR });
          return;
        }

        const eyepieceFl = LENS_FOCAL_LENGTHS[level];
        if (!eyepieceFl) return;

        EYEPIECE_FL = eyepieceFl;
        const fov = computeFovFromEyepiece(eyepieceFl);
        current_fov = fov;
        logFov = Math.log(fov);
        updateStellariumFov({ fov });
        updateStellariumBlur({ blur: 0 });
      }

      document.addEventListener("keydown", (e) => {
        const key = e.key;
        if (key >= "0" && key <= "6") {
          applyLensLevel(parseInt(key, 10));
        }
      });

      // ============================
      // Inicialización
      // ============================
      initializeStelEngine();
      window.Orientation.start();
      applyLensLevel(0);
    </script>
  </body>
</html>
