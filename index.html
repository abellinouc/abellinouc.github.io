<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AstroVis Minimalista</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background: #000;
      }

      #stel-canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      #zoom-indicator {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 10px 20px;
        border-radius: 8px;
        font-family: monospace;
        font-size: 16px;
        z-index: 1000;
      }
    </style>
  </head>
  <body>
    <canvas id="stel-canvas"></canvas>
    <div id="zoom-indicator">Lente: 1 (10mm)</div>

    <!-- Stellarium Web Engine -->
    <script src="stellarium-web-engine.js"></script>

    <script>
      let engine;
      let currentZoomLevel = 1;

      // Configuración de niveles de zoom fijos (Field of View en radianes)
      // Simulando lentes de telescopio: 10mm, 20mm, 32mm, 40mm
      const ZOOM_LEVELS = {
        1: { fov: 1.047, label: "10mm (60°)" }, // ~60 grados - vista amplia
        2: { fov: 0.524, label: "20mm (30°)" }, // ~30 grados - vista media
        3: { fov: 0.175, label: "32mm (10°)" }, // ~10 grados - zoom alto
        4: { fov: 0.0349, label: "40mm (2°)" }, // ~2 grados - zoom máximo
      };

      // Variables para orientación
      let deviceAlpha = 0;
      let deviceBeta = 0;
      let deviceGamma = 0;
      let permissionGranted = false;

      // ============================================================
      // INICIALIZACIÓN DE STELLARIUM WEB ENGINE
      // ============================================================
      StelWebEngine({
        wasmFile: "stellarium-web-engine.wasm",
        canvas: document.getElementById("stel-canvas"),
        async onReady(stel) {
          engine = stel;
          const core = stel.core;

          console.log("Stellarium Web Engine inicializado");

          // Configuración de fecha/hora actual usando Julian Date
          const now = new Date();
          core.observer.utc = now.getTime() / 86400000 + 2440587.5;

          // Ubicación por defecto (Santiago, Chile)
          const defaultLocation = {
            cityName: "Santiago",
            lat: -33.4489,
            lon: -70.6693,
            elev: 570,
            mag: 17.13,
          };

          core.observer.latitude = defaultLocation.lat * (Math.PI / 180);
          core.observer.longitude = defaultLocation.lon * (Math.PI / 180);
          core.observer.elevation = defaultLocation.elev;

          // Aplicar zoom inicial
          applyZoom(currentZoomLevel);

          // Dentro del index.html que sirve el puerto 8080:
          const baseUrl = "http://localhost:5000/";
          const baseUrlBig = "http://localhost:5000/";

          // Array para almacenar todas las promesas de carga de datos
          const dataSourcePromises = [];

          // Data sources básicas (estrellas minimal y base)
          dataSourcePromises.push(
            core.stars.addDataSource({
              url:
                baseUrl +
                "swe-data-packs/minimal/2020-09-01/minimal_2020-09-01_186e7ee2/stars",
              key: "minimal",
            })
          );
          dataSourcePromises.push(
            core.stars.addDataSource({
              url:
                baseUrl +
                "swe-data-packs/base/2020-09-01/base_2020-09-01_1aa210df/stars",
              key: "base",
            })
          );
          dataSourcePromises.push(
            core.landscapes.addDataSource({
              url: baseUrl + "landscapes/v1/guereins",
              key: "guereins",
            })
          );

          // Planetas y lunas del sistema solar
          [
            "moon",
            "sun",
            "jupiter",
            "mercury",
            "venus",
            "mars",
            "saturn",
            "uranus",
            "neptune",
            "io",
            "europa",
            "ganymede",
            "callisto",
            "moon-normal",
          ].forEach((p) => {
            dataSourcePromises.push(
              core.planets.addDataSource({
                url: baseUrl + `surveys/sso/${p}/v1`,
                key: p,
              })
            );
          });

          // Data sources adicionales (extended catalogs)
          dataSourcePromises.push(
            core.stars.addDataSource({
              url:
                baseUrl +
                "swe-data-packs/extended/2020-03-11/extended_2020-03-11_26aa5ab8/stars",
              key: "extended",
            })
          );
          dataSourcePromises.push(
            core.dss.addDataSource({
              url: baseUrlBig + "surveys/gaia/v1",
              key: "gaia",
            })
          );
          dataSourcePromises.push(
            core.skycultures.addDataSource({
              url: baseUrl + "skycultures/v3/western",
              key: "western",
            })
          );
          dataSourcePromises.push(
            core.dsos.addDataSource({
              url:
                baseUrl +
                "swe-data-packs/base/2020-09-01/base_2020-09-01_1aa210df/dso",
            })
          );
          dataSourcePromises.push(
            core.dsos.addDataSource({
              url:
                baseUrl +
                "swe-data-packs/extended/2020-03-11/extended_2020-03-11_26aa5ab8/dso",
            })
          );
          dataSourcePromises.push(
            core.milkyway.addDataSource({
              url: baseUrl + "surveys/milkyway/v1",
            })
          );
          dataSourcePromises.push(
            core.dss.addDataSource({ url: baseUrlBig + "surveys/dss/v1" })
          );
          dataSourcePromises.push(
            core.minor_planets.addDataSource({
              url: baseUrl + "mpc/v1/mpcorb.dat",
              key: "mpc_asteroids",
            })
          );
          dataSourcePromises.push(
            core.comets.addDataSource({
              url: baseUrl + "mpc/v1/CometEls.txt?v=2019-12-17",
              key: "mpc_comets",
            })
          );

          // Esperar a que todas las fuentes de datos se carguen
          try {
            await Promise.all(dataSourcePromises);
            console.log("✓ Todas las fuentes de datos cargadas correctamente");

            // Configuración visual después de cargar datos
            core.planets.hints_visible = true;
            core.dsos.hints_visible = true;
            core.minor_planets.hints_visible = false;
            core.dss.hints_visible = false;
            core.stars.hints_visible = true;
            core.comets.hints_visible = false;
            core.cardinals.visible = false;
            core.constellations.lines_visible = true;
            core.constellations.images_visible = false;
            core.constellations.labels_visible = true;
            core.star_relative_scale = 1.0;
            core.stars.label_amount = 3.0;
            core.exposure_scale = 2;
          } catch (error) {
            console.error("Error cargando fuentes de datos:", error);
          }

          // Solicitar permisos de sensores de movimiento
          requestOrientationPermission();
        },
      });

      // ============================================================
      // CONTROL DE ZOOM POR ARDUINO (TECLADO)
      // ============================================================
      function applyZoom(level) {
        if (!engine || !ZOOM_LEVELS[level]) return;

        currentZoomLevel = level;
        const zoomConfig = ZOOM_LEVELS[level];

        engine.core.fov = zoomConfig.fov;

        // Actualizar indicador visual
        document.getElementById(
          "zoom-indicator"
        ).textContent = `Lente: ${level} (${zoomConfig.label})`;

        console.log(`Zoom cambiado a nivel ${level}: ${zoomConfig.label}`);
      }

      // Escuchar teclas del Arduino (simulado como teclado)
      document.addEventListener("keydown", (event) => {
        const key = event.key;

        // Arduino envía teclas 1, 2, 3, 4
        if (key >= "1" && key <= "4") {
          const level = parseInt(key);
          applyZoom(level);
          event.preventDefault();
        }
      });

      // ============================================================
      // CONTROL DE ORIENTACIÓN POR SENSORES DE LA TABLET
      // ============================================================
      function requestOrientationPermission() {
        // En iOS 13+ se necesita permiso explícito
        if (
          typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function"
        ) {
          DeviceOrientationEvent.requestPermission()
            .then((permissionState) => {
              if (permissionState === "granted") {
                permissionGranted = true;
                startOrientationTracking();
                console.log("Permiso de orientación concedido");
              } else {
                console.warn("Permiso de orientación denegado");
                alert(
                  "Por favor, concede permisos de orientación para usar la app"
                );
              }
            })
            .catch(console.error);
        } else {
          // Android y navegadores que no requieren permiso
          permissionGranted = true;
          startOrientationTracking();
          console.log("Orientación habilitada automáticamente");
        }
      }

      function startOrientationTracking() {
        window.addEventListener("deviceorientation", handleOrientation, true);
      }

      function handleOrientation(event) {
        if (!engine || !permissionGranted) return;

        // Obtener ángulos del dispositivo
        deviceAlpha = event.alpha || 0; // Brújula (0-360°)
        deviceBeta = event.beta || 0; // Inclinación frontal (-180 a 180°)
        deviceGamma = event.gamma || 0; // Inclinación lateral (-90 a 90°)

        // Convertir a sistema de coordenadas de Stellarium
        // Yaw (azimut horizontal) - rotación alrededor del eje Z
        const yaw = -deviceAlpha * (Math.PI / 180);

        // Pitch (altitud vertical) - rotación alrededor del eje X
        // Beta va de -180 a 180, queremos mapear a pitch apropiado
        let pitch;
        if (Math.abs(deviceGamma) > 90) {
          // Tablet boca abajo
          pitch = (180 - deviceBeta) * (Math.PI / 180);
        } else {
          // Tablet en orientación normal
          pitch = deviceBeta * (Math.PI / 180);
        }

        // Limitar pitch para evitar gimbal lock
        pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

        // Aplicar orientación a Stellarium
        engine.core.observer.yaw = yaw;
        engine.core.observer.pitch = pitch;
      }

      // ============================================================
      // FUNCIONES ADICIONALES
      // ============================================================

      // Pantalla completa al hacer tap (útil para tablet)
      document.addEventListener("dblclick", () => {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch(console.error);
        } else {
          document.exitFullscreen().catch(console.error);
        }
      });

      // Evitar zoom por pinch en la tablet
      document.addEventListener(
        "touchmove",
        (event) => {
          if (event.touches.length > 1) {
            event.preventDefault();
          }
        },
        { passive: false }
      );

      // Mantener pantalla activa
      let wakeLock = null;
      async function requestWakeLock() {
        try {
          if ("wakeLock" in navigator) {
            wakeLock = await navigator.wakeLock.request("screen");
            console.log("Wake Lock activado");
          }
        } catch (err) {
          console.log("Wake Lock no disponible:", err);
        }
      }
      requestWakeLock();

      // Información de debug (opcional - eliminar en producción)
      setInterval(() => {
        if (engine && permissionGranted) {
          console.log(
            `Orientación - Alpha: ${deviceAlpha.toFixed(
              1
            )}°, Beta: ${deviceBeta.toFixed(1)}°, Gamma: ${deviceGamma.toFixed(
              1
            )}°`
          );
        }
      }, 5000);
    </script>
  </body>
</html>
